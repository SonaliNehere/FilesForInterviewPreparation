ğŸ” What is a Meta-Annotation in Spring Boot (and Java in general)?
A meta-annotation is an annotation that is used to annotate other annotations.
In Spring Boot and Spring Framework, meta-annotations are widely used to build custom annotations with built-in Spring behavior
	like @Component, @Transactional, @RequestMapping, etc.

ğŸ§  Java Meta-Annotations (Standard)
Java provides built-in meta-annotations like:

Meta-Annotation		Purpose
@Target				- Specifies where the annotation can be applied (method, class, field, etc.)
@Retention			- Defines how long the annotation is retained (source, class, runtime)
@Inherited			- Allows subclasses to inherit annotations
@Documented			- Includes annotation in Javadoc

âœ… Spring's Use of Meta-Annotations
Spring allows developers to create custom annotations that behave like Spring-managed beans or configurations by combining
 annotations.

ğŸ§¾ Example 1: Springâ€™s own @RestController
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Controller
@ResponseBody
public @interface RestController {
}
Here, @RestController is itself annotated with @Controller and @ResponseBody.
So, it acts as a meta-annotation wrapper to reduce boilerplate.

ğŸ§¾ Example 2: Creating Your Own Meta-Annotation
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface MyService {
}
Now, you can use @MyService on a class:

@MyService
public class MyBusinessLogic {
}
Spring will treat it like a @Component-scanned bean because of the meta-annotation.

ğŸ” Why Use Meta-Annotations in Spring Boot?
âœ… Reduce repetitive annotations
âœ… Create domain-specific annotations (like @SecuredAdmin, @JsonApi, etc.)
âœ… Promote cleaner and more maintainable code
âœ… Encapsulate complex configurations or behaviors

ğŸ§  Bonus: Composed Annotations
Spring calls these composed annotationsâ€”annotations that combine other annotations using meta-annotations.

âœ… Summary
Term				Description
Meta-Annotation		- Annotation that is applied on another annotation
Use in Spring		- To create custom annotations with built-in behavior
Example				- @RestController = @Controller + @ResponseBody
Custom Usage		- @MyService = @Component

==============================================================================

To implement basic authentication in Spring Boot using a properties file â€” and ensure it happens before the request reaches 
	the controller â€” you can achieve this in a clean way using Spring Security with in-memory user details configured in 
	application.properties or application.yml.

âœ… Goal:
Authenticate users before hitting the controller
Users and passwords defined in application.properties
Use Spring Security filter chain to intercept requests

âœ… Step-by-Step Implementation
1ï¸âƒ£ Add Spring Security Dependency
If you're using Maven:
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
2ï¸âƒ£ Configure Users in application.properties
spring.security.user.name=admin
spring.security.user.password=admin123
spring.security.user.roles=ADMIN
You can also add multiple users via custom configuration (explained below).

3ï¸âƒ£ Secure All Endpoints by Default
Spring Security automatically secures all endpoints unless configured otherwise.

4ï¸âƒ£ Create a Simple Controller
@RestController
@RequestMapping("/api")
public class DemoController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello, authenticated user!";
    }
}
If you now call /api/hello, it will prompt for Basic Auth credentials.

5ï¸âƒ£ Customize Security (Optional â€“ if you want multiple users or roles)
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            )
            .httpBasic() // enables Basic Auth
            .and()
            .csrf().disable(); // disable for testing purposes

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        var user1 = User.withUsername("admin")
                .password("{noop}admin123") // {noop} = no password encoder
                .roles("ADMIN")
                .build();

        var user2 = User.withUsername("user")
                .password("{noop}user123")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user1, user2);
    }
}
â˜ï¸ Here we define multiple users programmatically, not via application.properties.

ğŸ§ª Testing
Call your endpoint:
GET http://localhost:8080/api/hello
Use basic auth with:
Username: admin
Password: admin123

âœ… If credentials are correct, controller executes.
âŒ If wrong, Spring returns 401 Unauthorized before reaching the controller.

ğŸ” Optional: Custom Auth Message (Before Controller)
If you want to add custom auth logic, you can write a filter or authentication provider, but for most apps, the above setup 
	is clean and secure.

âœ… Summary
Goal								Achieved?
Auth before controller				- âœ… Yes
Config via application.properties	- âœ… Yes (simple user)
Easily extendable					- âœ… Use custom beans
Uses Spring Security filter chain	- âœ… Yes

================================================================================

ğŸ” 1. CSRF â€“ Cross-Site Request Forgery
âœ… What is it?
CSRF (Cross-Site Request Forgery) is an attack where a malicious website causes a userâ€™s browser to perform unintended actions
 on another website where the user is authenticated.

ğŸ” Real-world example:
Imagine you are logged into your banking site. Then, you visit a malicious site that silently sends a request to:
POST https://mybank.com/transfer-money
Body: amount=5000&toAccount=attacker123
Since you're already logged in, your session cookies are sent automatically, and the bank processes the request, thinking it's 
	from you!

ğŸ›¡ï¸ How to Prevent CSRF?
CSRF Tokens: The server sends a unique token with every form. When the client submits the form, it must include this token.
Spring Security automatically adds and validates CSRF tokens for state-changing requests (POST, PUT, DELETE).
ğŸ“Œ CSRF is a concern mainly for stateful apps using cookies for auth.

ğŸ” 2. JWT â€“ JSON Web Token
âœ… What is it?
JWT (JSON Web Token) is a compact, self-contained token used to securely transmit information between parties as a JSON object.

JWT is commonly used for:
Authentication (stateless login)
Authorization (roles/permissions)
Secure API communication

ğŸ§± JWT Structure:
A JWT has three parts:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.         // Header
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxN... // Payload
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c   // Signature
Header â€“ Type & signing algorithm
Payload â€“ Data like user ID, roles, issued-at time
Signature â€“ To verify the tokenâ€™s integrity

ğŸ” JWT Authentication Flow:
User logs in with username/password.
Server validates and returns a JWT token.
Client sends this token in Authorization header for each API call:
Authorization: Bearer <token>
Server validates token and grants access â€” no session needed!

ğŸ§¾ Key Differences Between CSRF and JWT
Feature				CSRF							JWT
Type				Security vulnerability			Authentication/Authorization method
Affects				Cookie-based sessions			Not applicable
Prevented By		CSRF tokens						N/A
Requires State?		Yes (session state)				No (stateless)
Use Case			Prevents cross-site attacks		Secure token-based auth

âœ… Summary
Term	Full Form						Role
CSRF	Cross-Site Request Forgery		Security threat to defend against
JWT		JSON Web Token					Mechanism for stateless auth

====================================================================================

ğŸŒ± What is Scope in Spring Boot?
Scope defines the lifecycle and visibility of a Spring bean â€” i.e., how long the bean instance lives and when a new instance
 is created.

âœ… Default Scope: singleton
One instance per Spring IoC container
Shared across the entire application context
Default for all Spring beans

ğŸ§¾ Common Spring Scopes
Scope				Description												Typical Use Case
singleton (default)	Single shared instance per Spring container				Stateless service beans
prototype			New instance every time the bean is requested			Stateful or short-lived objects
request				One bean instance per HTTP request						Web applications, per HTTP request data
session				One bean instance per HTTP session						User session data in web apps
application			One instance per ServletContext (application-wide)		Shared resources in a web app
websocket			One instance per WebSocket session						WebSocket-based communication

ğŸ”§ How to Set Scope in Spring Boot
You use the @Scope annotation on your bean or component class.
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope("prototype")
public class MyPrototypeBean {
    // ...
}
ğŸ§  Example: Common Scopes Usage
@Service
@Scope("singleton") // optional, singleton is default
public class MySingletonService {
    // One instance for entire app
}

@Component
@Scope("prototype")
public class MyPrototypeComponent {
    // New instance every injection/request
}

@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyRequestScopedBean {
    // One per HTTP request
}
Note: For scopes like request and session, Spring needs proxying to inject beans correctly into singleton beans.

ğŸ“ Summary Table
Scope		Description							Lifecycle
singleton	One shared instance					Application lifetime
prototype	New instance per request			When requested
request		One per HTTP request				Life of HTTP request
session		One per HTTP session				Life of HTTP session
application	One per ServletContext (web app)	Life of ServletContext

ğŸ§© When to use?
Singleton: Default, for stateless services
Prototype: For stateful or frequently changing beans
Request/Session: When building web apps that require per-request or per-user data storage

================================================================================

ğŸ” What is Transaction Management?
A transaction is a sequence of operations that must either all succeed or all fail as a single unit.
In Spring Boot, transaction management ensures data consistency, especially across multiple database operations.

ğŸ§¾ Example Scenario:
Deduct â‚¹500 from Account A âœ…
Add â‚¹500 to Account B âœ…
Both should succeed or both should fail â€” this is what a transaction ensures.

âœ… Key Concepts
Term			Meaning
Atomicity		All steps complete or none do
Consistency		DB moves from one valid state to another
Isolation		Transactions are isolated from each other
Durability		Once committed, the changes are permanent
These are known as the ACID properties.

ğŸš€ Spring Boot Transaction Management
âœ… Using @Transactional
@Service
public class TransferService {

    @Autowired
    private AccountRepository accountRepository;

    @Transactional
    public void transferMoney(Long fromId, Long toId, double amount) {
        Account from = accountRepository.findById(fromId).orElseThrow();
        Account to = accountRepository.findById(toId).orElseThrow();

        from.setBalance(from.getBalance() - amount);
        to.setBalance(to.getBalance() + amount);

        accountRepository.save(from);
        accountRepository.save(to);
    }
}
âœ… If any exception occurs inside transferMoney(), all changes will be rolled back.

âš™ï¸ Configuration (Optional)
Spring Boot automatically configures transactions if you use:
Spring Data JPA
Spring JDBC
A DataSource bean
Just annotate your service method with @Transactional.

ğŸ”„ Rollback Control
By default:
Rollback happens for unchecked exceptions (RuntimeException, Error)
No rollback for checked exceptions (IOException, etc)

âœ… To rollback on checked exceptions:
@Transactional(rollbackFor = Exception.class)
âš ï¸ Common Mistakes
Mistake													Why it's wrong
Calling a @Transactional method from the same class		Spring AOP wonâ€™t intercept â†’ no transaction
Forgetting @Transactional								DB changes won't rollback on failure
Not handling exceptions properly						Unexpected commit or partial updates

ğŸ§ª Interview Tip:
"Spring uses AOP (Aspect-Oriented Programming) behind the scenes to manage transactions using proxies. When you annotate a 
	method with @Transactional, Spring creates a proxy and wraps the method call to start, commit, or rollback the transaction."

ğŸ”§ Transaction Propagation Types
Type			Meaning
REQUIRED		Join existing or create a new transaction (default)
REQUIRES_NEW	Always start a new transaction
NESTED			Start a nested transaction
NOT_SUPPORTED	Run without a transaction
NEVER			Fail if a transaction exists
MANDATORY		Must run in an existing transaction

==============================================================

ğŸ¯ What is AOP in Simple Terms?
AOP means writing extra code (like logging, security, transactions) separately from your main business logic, but it still runs 
	automatically when needed.

You donâ€™t need to write logging or security code in every method. Just write it once, and AOP will apply it everywhere you need.

ğŸ§  Real-Life Example:
Imagine a salon ğŸ’‡â€â™€ï¸
You go for:
Haircut âœ‚ï¸ (Main logic)

The salon also:
Sanitizes chair ğŸ§¼ (before)
Says thank you ğŸ™ (after)

Now, instead of writing these steps (sanitize, thank you) in every haircut method, you write it once using AOP.

ğŸ¤– In Code Terms:
Without AOP:
public void bookAppointment() {
  System.out.println("Sanitize chair");
  System.out.println("Doing haircut...");
  System.out.println("Say thank you");
}
You repeat "sanitize" and "thank you" in every method.

With AOP:
@Before
public void sanitizeChair() {}

@After
public void sayThankYou() {}

public void bookAppointment() {
  System.out.println("Doing haircut...");
}
âœ… Now these actions happen automatically. You keep your main logic clean!

ğŸ”§ How to Use AOP in Spring Boot
Add @Aspect class
Write code with @Before, @After, @Around, etc.
Target where you want it to apply (e.g., all methods in a package)

ğŸ”¥ Where You See AOP in Real Projects
Task				AOP Used?	How It Helps
Logging					âœ…			Print logs before/after method
Transactions			âœ…			Start/commit/rollback automatically
Security checks			âœ…			Check token/roles before method
Validation				âœ…			Validate inputs globally

ğŸ“Œ Summary
Term		Means
Aspect		Extra logic (like logging)
Advice		When that logic should run
Pointcut	Where (which method/package)
JoinPoint	Exact place (method call)

==========================================================================

ğŸ”„ What is a Circular Dependency?
A circular dependency happens when Bean A depends on Bean B, and Bean B also depends on Bean A â€” directly or indirectly.
This creates a loop and Spring fails to inject the beans.

âŒ Example of Circular Dependency
@Component
public class A {
    @Autowired
    private B b;
}

@Component
public class B {
    @Autowired
    private A a;
}

This will throw:
org.springframework.beans.factory.UnsatisfiedDependencyException:
Circular reference involving A and B

âœ… How to Fix It
âœ… Option 1: Use @Lazy
@Component
public class A {
    @Autowired
    @Lazy
    private B b;
}
âœ… This tells Spring: "Delay the creation of B until itâ€™s really needed," breaking the cycle.

âœ… Option 2: Use Constructor Injection + @Lazy
@Component
public class A {
    private final B b;
    public A(@Lazy B b) {
        this.b = b;
    }
}
ğŸ” Constructor injection is preferred for testability and immutability.

âœ… Option 3: Refactor Dependencies
Split common logic into a third bean (C) and inject that instead.
@Component
public class CommonService {}

@Component
public class A {
    @Autowired
    private CommonService common;
}

@Component
public class B {
    @Autowired
    private CommonService common;
}
âœ… This is the best long-term fix â€” it removes tight coupling between A and B.

âœ… Option 4: Use Setter Injection
If you donâ€™t want to use @Lazy, you can break the cycle with setter injection:
@Component
public class A {
    private B b;

    @Autowired
    public void setB(B b) {
        this.b = b;
    }
}
ğŸ§  Pro Tips
Situation						Recommended Fix
Tight loop between 2 beans		Use @Lazy on one
Too much coupling				Refactor shared logic to new bean
Complex service dependencies	Consider event listeners or design changes
=========================================================================

âœ… What is a Spring Bean?
A Spring Bean is any object that is managed by the Spring container (created, injected, and destroyed by Spring).

ğŸŸ¨ 1. @Component â€“ Annotation-based Bean
@Component
public class MyService {
    // automatically registered as a bean
}
âœ… Key Points:
Use it on classes
Works with component scanning
Can be used with @Service, @Repository, @Controller (they are specializations of @Component)
Automatically picked up if the package is scanned

ğŸŸ© 2. @Bean â€“ Method-based Bean
@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyService();
    }
}
âœ… Key Points:
Use it on methods
Typically used when:
You need to create a bean manually
You donâ€™t have access to modify the source class
Often used with third-party libraries

ğŸ†š Component vs Bean â€“ Clear Comparison
Feature					@Component						@Bean
Where used				On a class						On a method inside a @Configuration class
Who creates it			Spring via component scanning	You create manually in a config method
When to use				For your own classes			For external classes or complex logic
Autowiring support		âœ… Yes							âœ… Yes
Custom creation logic	âŒ No							âœ… Yes (you control creation)

ğŸ§  Real-life Analogy
Situation															Use
You wrote the class													@Component
Class comes from a library (3rd party)								@Bean
You need full control over bean creation (e.g., constructor args)	@Bean

âœ… Bonus: Other @Component Variants
Annotation		Meaning
@Component		Generic bean
@Service		Business logic layer
@Repository		DAO/persistence layer
@Controller		Web layer (MVC controller)

All of them behave like @Component â€” just semantically different.
==============================================================================


ğŸŒŸ JWT Authentication & Authorization â€” Complete Flow with All Scenarios

I will explain in 4 stages:

1ï¸âƒ£ Login (Authentication) â€“ How token is created
2ï¸âƒ£ API Request (Authorization) â€“ How token is validated
3ï¸âƒ£ Signature Verification â€“ How server detects tampering
4ï¸âƒ£ Positive & Negative Scenarios

ğŸ” 1. USER LOGIN (Authentication) â€“ JWT Creation Flow
Step 1: User sends credentials
POST /login
{
  username: "sonali",
  password: "1234"
}

Step 2: Server verifies username + password

If correct â†’ continue
If wrong â†’ return 401 Unauthorized

Step 3: Server prepares user details to put in token

Example payload:

{
  "sub": "sonali",
  "roles": ["ADMIN", "USER"],
  "iat": 171000000,
  "exp": 1710003600
}

Step 4: Server signs the token

Signature =

HMAC_SHA256(
   Base64(header) + "." + Base64(payload),
   secretKey
)

Step 5: Server returns JWT
header.payload.signature

Step 6: Client stores token
localStorage
sessionStorage
cookies

âœ” Authentication is complete.

ğŸ”’ 2. API REQUEST (Authorization) â€“ JWT Validation Flow

Now user wants to call:

GET /api/products

Step 1: Client sends JWT in header
Authorization: Bearer header.payload.signature

Step 2: Spring Security intercepts request (JwtFilter)
Step 3: Spring extracts header + payload from token
Step 4: Spring recomputes signature using secret key
server_signature = HMAC_SHA256(header + payload, secretKey)

Step 5: Compare both signatures
if (server_signature == token_signature)
      token is valid
else
      token invalid (401)

Step 6: If valid â†’ load roles from payload
roles = ["ADMIN"]

Step 7: Spring checks if user has access

If endpoint requires ADMIN:

User has ADMIN â†’ allow

User has USER only â†’ 403 Forbidden

âœ” Authorization complete.

ğŸ§  3. SIGNATURE VERIFICATION â€” Why JWT is secure

Signature protects the token.

If client modifies even 1 character:

Example:

"role": "USER" â†’ "role": "ADMIN"


Then Spring recalculates signature â†’ mismatch â†’ reject.

âœ” Prevents tampering
âœ” Prevents fake tokens
âœ” Protects your app

âš¡ 4. ALL POSITIVE & NEGATIVE SCENARIOS
âœ… POSITIVE FLOW (Everything is correct)
Correct token + correct signature + not expired

âœ” User is authenticated
âœ” Roles are extracted
âœ” Access allowed if roles match

âŒ NEGATIVE SCENARIOS (Every failure case)
âŒ 1. Wrong or Modified Token

If the client sends a token with changed payload:
header.payload.modified_signature

Spring recalculates signature â†’ mismatch

ğŸ‘‰ 401 Unauthorized: Invalid JWT Signature

âŒ 2. Token Expired

When exp < current time:

ğŸ‘‰ 401 Unauthorized â€“ Token Expired

âŒ 3. No Token Provided

Client sends no Authorization header:

ğŸ‘‰ 401 Unauthorized or 403 Forbidden

âŒ 4. Wrong Secret Key Used (Attacker creates token)

Attacker tries:
Fake token
Fake signature
Without the same secret key â†’ impossible to match.

ğŸ‘‰ Token rejected â€“ 401

âŒ 5. Token Signed with Different Algorithm

Header shows HS256 but signature is different.

ğŸ‘‰ Signature mismatch â€“ 401

âŒ 6. User Does Not Have Required Role

Token valid, signature valid, but user role not allowed.

Example:

Token role: USER

Endpoint requires: ADMIN

ğŸ‘‰ 403 Forbidden

(This is authorization failure.)

âŒ 7. Malformed Token (Wrong Format)

Token not in 3 parts (header.payload.signature)

ğŸ‘‰ 400 Bad Request â€“ Malformed JWT

â­ FINAL INTERVIEW SUMMARY (Perfect 5-line Answer)

â€œJWT handles authentication by issuing a signed token after verifying login credentials.
For each request, the client sends this token in the Authorization header.
Spring Security extracts the token, recreates the signature using the secret key, and compares it with the tokenâ€™s signature.
If they match and token isnâ€™t expired, request is authenticated.
Authorization then checks user roles from the payload to allow or deny access.â€

âœ… AUTHENTICATION happens first (signature verification)

Authentication = â€œIs this a real user?â€

Authentication checks:

1ï¸âƒ£ Is token present?
2ï¸âƒ£ Is token valid?
3ï¸âƒ£ Is signature correct?
4ï¸âƒ£ Is token not expired?

If all are true â†’ Spring sets the user as authenticated.

At this point Spring says:
â€œOkay, this user is genuine.â€

But Spring still does NOT allow access to every endpoint.

ğŸ” After Authentication, Authorization happens next

Authorization = â€œIs this user allowed to access this endpoint?â€

Authorization checks:

âœ” Spring reads roles inside JWT payload:
Example payload:

"roles": ["ADMIN", "USER"]


âœ” Spring compares these roles with the role required by the endpoint.

Example:

Endpoint:
"
@GetMapping("/admin/data")
@PreAuthorize("hasRole('ADMIN')")
"


If user role is:
roles = ["ADMIN"]
âœ” Access allowed

If user role is:
roles = ["USER"]
âŒ Access denied with 403 Forbidden

â­ THE EXACT FLOW (Very Simple)
1ï¸âƒ£ Signature matched â†’ Authentication successful

(Spring now trusts the user)

2ï¸âƒ£ Token not expired â†’ Authentication continues
3ï¸âƒ£ Role inside token â†’ Authorization check

(Spring verifies if user has permission for this URL)

ğŸ¯ Interview-perfect statement

You can say this:

â€œJWT Authentication is verifying the tokenâ€™s signature and expiry to confirm the userâ€™s identity. After authentication, authorization happens where
 Spring checks the roles inside the JWT payload to decide whether the user can access the endpoint.â€
 
 ===============================================================================================
 
 


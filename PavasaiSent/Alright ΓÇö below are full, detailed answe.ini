Alright — below are full, detailed answers to all 100 Java + Spring Boot interview questions you asked for. I kept them concise but thorough enough that you can study, rehearse, and use them in interviews. I’ll be blunt where it matters: memorize core tradeoffs, common pitfalls, and the real-world examples — interviewers love that.

1–100: Questions with full explanations
	1.	Difference between JDK, JRE, JVM.
	•	JVM (Java Virtual Machine): The runtime that executes compiled bytecode (.class). It provides platform independence, garbage collection, JIT compilation, class loading.
	•	JRE (Java Runtime Environment): Contains the JVM + standard libraries (rt.jar historically), and runtime tools needed to run Java applications. You install JRE to run apps.
	•	JDK (Java Development Kit): Superset of JRE — includes compiler (javac), tools (jarsigner, javadoc), and development libraries. Use JDK to develop and build Java applications.
Interview tip: If they ask versions, mention modularization since Java 9 (JPMS) — modules are part of JDK/JRE changes.
	2.	Explain OOP concepts with examples (Encapsulation, Inheritance, Polymorphism, Abstraction).
	•	Encapsulation: Bundling data and methods; control access via private fields + public getters/setters. Example: BankAccount hides balance and exposes deposit()/withdraw().
	•	Inheritance: class SavingsAccount extends BankAccount — reuse and extend behavior. Watch for Liskov Substitution Principle.
	•	Polymorphism: One interface, many implementations. Example: List l = new ArrayList(); or method overriding (runtime polymorphism).
	•	Abstraction: Expose required behavior while hiding details — interfaces or abstract classes. Example: Shape.draw() abstracted for Circle, Rectangle.
Interview tip: Show understanding of SOLID principles and when inheritance is harmful.
	3.	What is method overloading vs overriding?
	•	Overloading: Same method name, different parameter list in same class (compile-time). Example: add(int,int) and add(double,double).
	•	Overriding: Subclass provides implementation for superclass method (@Override) with same signature — runtime polymorphism. super.method() can be used.
Pitfall: Changing return type only doesn’t overload/override (covariant returns allowed for overriding).
	4.	Can we override a private/static/final method?
	•	Private: No — private methods are not visible to subclasses; they are class-private. You can define a new method with same signature, but it’s not overriding.
	•	Static: Cannot be overridden; it’s hidden (method hiding). Calling depends on reference type.
	•	Final: Cannot override final methods; final prevents further overriding.
Interview tip: Understand polymorphism vs static binding.
	5.	What is a constructor? Types?
	•	Constructor: Special method invoked on object creation to initialize state. Name = class, no return type.
	•	Types: Default (no-arg) constructor provided by compiler if none present; parameterized constructors; copy constructor (user-defined); private constructors (singleton pattern).
Pitfall: Remember order: static initializers → instance initializers → constructor.
	6.	What is immutability? How do you create an immutable class?
	•	Immutable object cannot change state after creation. Benefits: thread-safety, easy reasoning.
	•	How: Make class final (or private constructors + no subclassing), private final fields, initialize via constructor, no setters, defensive copy mutable fields when returning or accepting (e.g., Date, collections), ensure no methods expose internals.
	•	Example: String is immutable. Use Collections.unmodifiableList or defensive clones for collections.
	7.	What is the String pool? Why is String immutable?
	•	String pool (intern pool): JVM stores unique string literals in a common pool to save memory. "abc" literal references pooled object. String.intern() can add/lookup strings in the pool.
	•	Why immutable: Security, caching (hashCode caching), thread-safety, efficient sharing. Mutation would break interned sharing and hash-based collections.
Tip: Know performance implications of concatenation — use StringBuilder in loops (Java compiler optimizes simple concatenations).
	8.	Differences: String, StringBuilder, StringBuffer.
	•	String immutable — new instance per modification.
	•	StringBuilder mutable, not synchronized — fast for single-threaded modifications.
	•	StringBuffer mutable, synchronized — thread-safe but slower.
Interview tip: Use StringBuilder in most cases unless concurrency required.
	9.	What is the difference between == and .equals()?
	•	== checks reference equality for objects (and value equality for primitives).
	•	.equals() checks logical equality — default is reference equality in Object, overridden in classes like String, Integer. Implement equals() consistent with hashCode().
	10.	What is hashCode() and equals() contract?
	•	equals() must be reflexive, symmetric, transitive, consistent, and null returns false.
	•	If equals() returns true for two objects, their hashCode() must be equal. If hashCode() is equal, equals() may still be false.
	•	Overriding equals() requires overriding hashCode() to maintain behavior in hash-based collections (HashMap/HashSet).
Pitfall: Mutable fields used in equals/hashCode can break collection behavior when mutated.
	11.	What is a marker interface? Examples?
	•	Marker interface has no methods — used to mark classes for behavior by runtime/libraries. Examples: Serializable, Cloneable.
	•	Alternatives now: annotations (preferable for metadata). Java uses marker interfaces historically.
	12.	What is the difference between abstract class and interface?
	•	Abstract class: can have state (fields), constructors, concrete methods, protected members; single inheritance.
	•	Interface: Java 8+ supports default and static methods; no instance fields (except constants). Multiple interfaces can be implemented.
When to use: Use interface for behavior contract; abstract class when sharing implementation/state.
	13.	What are default methods in interfaces?
	•	Introduced in Java 8: methods in interface with default provide implementation. Helps add methods to existing interfaces without breaking implementers.
	•	Beware of diamond problem; implementing class can override default methods to resolve conflicts.
	14.	What is functional programming in Java?
	•	FP emphasizes immutability, pure functions, higher-order functions, and declarative operations. Java supports FP via lambdas, streams, Function/Predicate interfaces. Encourages side-effect-free operations and parallel pipelines.
	15.	Explain Lambda expressions.
	•	Lambdas provide concise syntax for implementing a functional interface (single abstract method). Example: (a,b) -> a + b. They enable passing behavior as parameters, used heavily with Streams and Executors.
Tip: Understand scope rules (effectively final variables), this inside lambda refers to enclosing instance, unlike anonymous inner class.
	16.	What is a Stream? Stream operations? (map, filter, reduce)
	•	Streams provide pipelines of data transformations: source → intermediate ops (lazy) → terminal op (e.g., collect, forEach).
	•	map: transforms elements. filter: selects elements. reduce: aggregates into single value. Streams allow parallel operations (parallelStream()), but watch thread-safety and non-deterministic order for unordered streams.
	17.	What is Optional? Why is it used?
	•	Optional<T> wraps possibly-null values to avoid NullPointerException and express absence explicitly. Methods: of, ofNullable, orElse, orElseGet, orElseThrow, map, flatMap. Not recommended for fields; good for return types.
	18.	What is exception handling? Checked vs unchecked exceptions.
	•	Exceptions manage error conditions. Checked exceptions (extend Exception but not RuntimeException) must be declared or handled (e.g., IOException). Unchecked exceptions (RuntimeException and Error) need not be declared. Prefer unchecked for programming errors, use checked for recoverable conditions.
	19.	What is try-with-resources?
	•	Introduced in Java 7: try (Resource r = ...) {} automatically closes resources implementing AutoCloseable at the end, removing boilerplate finally blocks and preventing resource leaks.
	20.	What are generics? Why are they used?
	•	Generics enable type parameters (e.g., List<String>), enabling compile-time type safety and avoiding casts. They are implemented via type erasure at runtime (see question 21).
	21.	What is type erasure?
	•	Java generics are implemented by erasing type parameters at compile time — the runtime doesn’t know generic type arguments. This ensures backward compatibility but restricts runtime type checks (e.g., new T[], instanceof with generic types). Use TypeToken or Class<T> where runtime type is needed.
	22.	Explain final, finally, finalize.
	•	final: keyword used with variables (constant), methods (cannot be overridden), and classes (cannot be subclassed).
	•	finally: block in try/catch ensures execution (resource cleanup) even if exceptions occur.
	•	finalize(): deprecated; called by GC before object reclamation — not reliable; avoid its use.
	23.	What is Java Memory Model?
	•	Defines how threads interact through memory and how changes in one thread become visible to others. It explains volatile, synchronized, happens-before relations and prevents reordering issues. Understand visibility and ordering guarantees.
	24.	What is Garbage Collection? Types of GC algorithms.
	•	Automatic reclaim of unreachable objects. Major algorithms/collectors: Serial, Parallel (Throughput), CMS (concurrent mark-sweep, older), G1 (Garbage First — default in modern JDKs), ZGC and Shenandoah (low-latency collectors). Understand generational GC: young generation (Eden + survivors) and old generation, and minor vs full GC.
	25.	How does JVM load a class (ClassLoader mechanism)?
	•	Class loading phases: Loading (find binary), Linking (verification, preparation, resolution), Initialization (static initializers). Hierarchical ClassLoaders: Bootstrap → Extension → System (Application) → custom. Parent delegation prevents malicious overriding of core classes.
	26.	Difference: List, Set, Map.
	•	List: Ordered collection, allows duplicates (ArrayList, LinkedList).
	•	Set: No duplicates; may be unordered (HashSet) or ordered (LinkedHashSet) or sorted (TreeSet).
	•	Map: Key-value pairs; keys unique (HashMap, TreeMap, LinkedHashMap).
Tip: Know common operations and complexity (HashMap average O(1) get/put).
	27.	Difference between ArrayList and LinkedList.
	•	ArrayList: resizable array, fast random access O(1), slower inserts/removes at arbitrary positions O(n) due to shifting.
	•	LinkedList: doubly-linked list, no random access (O(n)), cheap inserts/removes using iterators at known positions. Memory overhead higher due to node objects.
	28.	How HashMap works internally? (VERY IMPORTANT)
	•	HashMap uses array of buckets (table). Key’s hashCode() mapped to index via hash & (capacity - 1) after a supplemental hash. Buckets contain linked lists or (since Java 8) balanced trees (TreeNode) when chain length exceeds threshold. On put: compute bucket, search equals, replace or append. Resizing doubles capacity when load factor (default 0.75) exceeded and rehashes entries. Since Java 8, trees reduce O(n) worst-case to O(log n).
	29.	What is hashing? What is collision? How handled?
	•	Hashing: transform object to int via hashCode() used to determine bucket index.
	•	Collision: two keys map to same bucket. Handling: chaining (linked lists/trees in HashMap), open addressing (probing) in some implementations. Good hashCode design minimizes collisions.
	30.	HashMap vs ConcurrentHashMap differences.
	•	HashMap not thread-safe. ConcurrentHashMap is thread-safe and uses internal partitioning/locks or lock-free algorithms (segment locking in older versions; in Java 8 uses CAS + synchronized for bins). ConcurrentHashMap doesn’t allow null keys/values; operations like computeIfAbsent are atomic. Iterators are weakly consistent — don’t throw ConcurrentModificationException.
	31.	Fail-fast vs fail-safe iterators.
	•	Fail-fast: throw ConcurrentModificationException if collection modified structurally while iterating (e.g., ArrayList, HashMap iterators).
	•	Fail-safe: work on a copy of collection (e.g., CopyOnWriteArrayList), do not throw exceptions, but do not reflect concurrent updates.
	32.	SynchronizedMap vs ConcurrentHashMap.
	•	Collections.synchronizedMap(map): synchronizes entire map; single lock for all operations — simple but low concurrency. ConcurrentHashMap allows higher concurrency with partitioned locking/CAS and fine-grained updates; better for high throughput multi-threaded access.
	33.	TreeMap vs HashMap vs LinkedHashMap.
	•	HashMap: unordered, fastest average operations.
	•	LinkedHashMap: maintains insertion or access order via linked list; can implement LRU cache by access order and overriding removeEldestEntry.
	•	TreeMap: sorted by keys using comparator, operations O(log n). Use when ordered traversal by keys needed.
	34.	What is CopyOnWriteArrayList?
	•	Thread-safe list where mutative operations create a new copy of the underlying array. Good for read-heavy, write-light scenarios. Iterators are snapshot-based and won’t see concurrent modifications.
	35.	How are elements stored in PriorityQueue?
	•	Backed by a binary heap (array representation), providing O(log n) for insert and remove operations. Iteration order is not sorted; only peek()/poll() returns the least/greatest element per comparator.
	36.	Difference between Comparable and Comparator.
	•	Comparable (implements in class) defines natural ordering via compareTo. Comparator is external strategy used to define ordering, can be passed to collections or use Comparator.comparing. Since Java 8, comparators are more powerful with chaining, null handling, and method references.
	37.	Why is HashSet backed by HashMap?
	•	Implementation detail: HashSet uses a HashMap with values as dummy PRESENT object. Keys are set elements; reuses HashMap performance and algorithms.
	38.	How to make a collection thread-safe?
	•	Options: use concurrent collections (ConcurrentHashMap, ConcurrentLinkedQueue), use Collections.synchronizedList/set/map, use explicit synchronization (synchronized, locks), or design immutable collections (unmodifiable) and thread-safe publishing on construction.
	39.	What is blocking queue?
	•	Queue that blocks producers/consumers when full/empty. Implementations: ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue. Useful for producer-consumer patterns and thread-pooling.
	40.	What is WeakHashMap?
	•	Map with weak keys — entries can be garbage collected when keys are no longer strongly referenced elsewhere. Useful for caches where entries should vanish when key is no longer referenced.
	41.	Difference between process and thread.
	•	Process: OS-level execution unit with its own memory space, resources.
	•	Thread: Lightweight execution path within a process sharing memory and resources. Multiple threads can run concurrently in a process.
	42.	What is thread lifecycle?
	•	States: NEW → RUNNABLE → BLOCKED/WAITING/TIMED_WAITING → TERMINATED. RUNNABLE maps to runnable queue; OS scheduling decides actual running. Methods: start() spawns thread, join() waits, interrupt() signals.
	43.	Ways to create a thread in Java.
	•	Implement Runnable and pass to Thread. Implement Callable + submit to ExecutorService (returns Future). Extend Thread class (less recommended). Use executors/fork-join pools for better control.
	44.	Difference between Runnable and Callable.
	•	Runnable has run() and returns void and can’t throw checked exceptions. Callable<V> has call() returning a result and can throw checked exceptions — use with Future.
	45.	What is ThreadPool? Why use Executor framework?
	•	ThreadPool reuses threads to handle many tasks, reduces overhead of creating threads. Executor/ExecutorService provides abstraction for task submission, lifecycle management (shutdown), scheduling (ScheduledExecutorService), and configurable thread pools (ThreadPoolExecutor).
	46.	What is synchronization? Types?
	•	Mechanism to control access to shared resources to avoid race conditions. Types: intrinsic locks via synchronized (method/block), explicit locks with java.util.concurrent.locks.Lock (ReentrantLock), read-write locks (ReadWriteLock), and concurrent data structures.
	47.	What is a deadlock? How to avoid?
	•	Deadlock: two or more threads waiting indefinitely for locks held by each other. Avoidance: order locking consistently, use tryLock with timeouts, reduce lock granularity, avoid holding locks during I/O or blocking operations, prefer lock-free algorithms or higher-level concurrency utilities.
	48.	What is race condition?
	•	When multiple threads access/modify shared data concurrently and outcome depends on scheduling. Solved via synchronization, atomic variables, or designing immutable/lock-free structures.
	49.	What is volatile keyword?
	•	Ensures visibility of changes to variables across threads and prevents certain reordering; reads/writes go directly to main memory. volatile does not provide atomicity for read-modify-write operations (use Atomic* for atomic updates). Use for flags or variables where full synchronization is unnecessary.
	50.	What is synchronized keyword?
	•	Provides mutual exclusion and memory visibility — only one thread may hold the monitor for the object/class at a time. Used on methods or blocks. Heavy use can cause contention; prefer finer-grained locks or concurrent constructs.
	51.	What is ReentrantLock vs synchronized?
	•	ReentrantLock (from java.util.concurrent.locks) offers advanced features: tryLock, timed lock, interruptible lock acquisition, fair locking option; must unlock in finally. synchronized is simpler and automatically released, and since Java 6/7 JVM optimized synchronized well.
	52.	What is CountDownLatch and CyclicBarrier?
	•	CountDownLatch: one-time-use latch counting down from N to 0; threads wait until count reaches 0. Useful for waiting for multiple tasks to finish.
	•	CyclicBarrier: barrier that reuses once all parties arrive; can run barrier action upon completion. Useful for phased computation.
	53.	What is Semaphore?
	•	Controls number of permits allowing access to a resource. Useful for limiting concurrent access (e.g., DB connections), or implementing resource pools.
	54.	What is Future and CompletableFuture?
	•	Future: represents result of async computation, has blocking get(). CompletableFuture (Java 8) supports non-blocking, reactive-style callbacks, chaining, combining, and async execution with thenApply, thenCompose, exceptionally.
	55.	ThreadLocal usage?
	•	Provides thread-confined variables: each thread has its own value instance. Use for per-thread context (e.g., transaction ID, user context) but must remove values to prevent memory leaks in pooled thread environments (e.g., web containers).
	56.	What is Fork/Join framework?
	•	Java concurrency framework for divide-and-conquer parallelism using ForkJoinPool and RecursiveTask/RecursiveAction. Efficiently balances work via work-stealing. Good for CPU-bound tasks that can be recursively subdivided.
	57.	What is Atomic package?
	•	java.util.concurrent.atomic provides lock-free thread-safe single-variable operations (AtomicInteger, AtomicReference, AtomicLong) implemented via CAS (compare-and-swap). Useful for counters and atomic updates without locks.
	58.	Difference between parallel stream vs sequential stream.
	•	parallelStream() divides work across multiple threads using common ForkJoinPool. Good for CPU-bound tasks and large data sets but can cause thread contention, not suitable for stateful operations or shared mutable data. Order may change unless using ordered collectors.
	59.	Why is double-checked locking used?
	•	Optimize singleton initialization: check null before acquiring lock, recheck inside lock to avoid race. Must use volatile for singleton instance to prevent instruction reordering issues (without volatile, double-checked locking can be broken).
	60.	What is CAS (Compare And Swap)?
	•	Low-level atomic primitive used in lock-free algorithms: compare current value to expected; if match, swap to new value. Implemented in Java via Unsafe or Atomic* classes. CAS avoids locks but may suffer from ABA problem.
	61.	JVM architecture (ClassLoader, Heap, Stack, Metaspace).
	•	ClassLoader loads classes. Heap: runtime data area for objects (young + old). Stack: per-thread stack frames for method calls/local primitives. Metaspace (since Java 8) holds class metadata (replaces PermGen). GC works primarily on Heap; Class unloading affects Metaspace.
	62.	What are JVM memory regions?
	•	Young generation (Eden + Survivor spaces), Old generation (tenured), Metaspace for class metadata, Code Cache for JIT-compiled code, and thread stacks. Each collector tunes these differently.
	63.	Difference between stack and heap.
	•	Stack: stores primitive local variables and references, LIFO method frames, thread-local. Small, fast. StackOverflowError if too deep recursion or huge stack frames.
	•	Heap: stores objects, shared among threads, garbage-collected. OutOfMemoryError when memory exhausted.
	64.	What is GC root?
	•	Objects referenced directly by GC roots (e.g., local variables in stacks, static fields, JNI references) are considered reachable. GC marks from roots to find live objects.
	65.	What causes OutOfMemoryError?
	•	Heap exhaustion (too many objects, memory leak due to retained references), native memory exhaustion (e.g., direct buffers), PermGen/Metaspace overflow (classloader leaks), too small heap settings.
	66.	What causes StackOverflowError?
	•	Excessive stack depth (deep recursion) or huge local variables causing frame size too large. Fix by reducing recursion depth or increasing thread stack size (not always desirable).
	67.	How to monitor JVM? (jconsole, jvisualvm, jstat, jmap)
	•	Tools: jvisualvm for profiling, jconsole for JMX metrics, jstat for GC statistics, jmap for heap dumps, jstack for thread dumps. Use these to diagnose leaks, hotspots, thread contention, GC pauses.
	68.	What is JIT compiler?
	•	Just-In-Time compiler translates hot bytecode into native machine code at runtime to speed execution. Can perform optimizations like inlining and escape analysis; runtime profiling helps optimize frequently used code.
	69.	What is escape analysis?
	•	JVM optimization that determines if an object does not escape method scope; can allocate it on stack or eliminate synchronization. Reduces GC pressure.
	70.	JVM tuning parameters (-Xmx, -Xms).
	•	-Xmx: max heap size; -Xms: initial heap size. Also -XX:MaxMetaspaceSize, -XX:+UseG1GC to select GC, -Xss for thread stack size. Tune based on load, GC behavior, and profiling.
	71.	What is Spring Framework?
	•	Java framework for building enterprise apps. Core features include IoC/DI, AOP, transaction management, data access abstraction, MVC. It reduces boilerplate and provides integration modules (Spring Data, Security, Cloud).
	72.	What is IoC (Inversion of Control)?
	•	Principle where flow control of a program is inverted: container creates and injects dependencies into objects rather than objects creating dependencies. Spring’s IoC container manages bean lifecycle and injection.
	73.	What is Dependency Injection? Types?
	•	DI injects dependencies into objects via constructor injection, setter injection, or field injection (reflection-based). Constructor injection is preferred (immutable dependencies, easier testing); field injection is discouraged for testing and clarity.
	74.	Bean scopes (singleton, prototype…).
	•	Common scopes: singleton (single instance per Spring context), prototype (new instance per injection), request/session (web scopes), application, websocket. Understand lifecycle differences.
	75.	Bean lifecycle in Spring.
	•	Creation: constructor/DI → BeanPostProcessor pre-process → @PostConstruct or afterPropertiesSet() → ready for use → on shutdown, @PreDestroy or DisposableBean, BeanPostProcessor post-process. BeanFactory and ApplicationContext manage lifecycle.
	76.	Difference between @Component, @Service, @Repository, @Controller.
	•	Stereotype annotations for readability and specialized behavior: @Component generic, @Service indicates service layer, @Repository indicates DAO and can translate persistence exceptions to Spring’s DataAccessException, @Controller for MVC controllers. Functionally similar for component scanning.
	77.	What is AOP (Aspect Oriented Programming)?
	•	AOP separates cross-cutting concerns (logging, transactions, security) into aspects. Spring AOP uses proxies (dynamic proxies or CGLIB) to weave advice (before, after, around) into method execution. Useful for logs, metrics, and transactions.
	78.	What is @Autowired? Field vs Constructor injection?
	•	@Autowired injects dependencies. Constructor injection preferred: supports immutability and easier testing; fields are less testable and hide dependencies. Spring 4.3+ infers @Autowired on single constructor.
	79.	What is ApplicationContext?
	•	Spring’s IoC container interface that loads bean definitions, manages lifecycle, supports event propagation, internationalization. BeanFactory is lower-level; ApplicationContext adds features.
	80.	How does Spring handle transactions? @Transactional.
	•	@Transactional demarcates transactional boundaries. Spring creates proxies that begin/commit/rollback transactions. Understand propagation (REQUIRED, REQUIRES_NEW), isolation levels, and rollback rules (by default rollback on unchecked exceptions). Use transactions at service layer, not controller. For @Transactional to work, method must be invoked via proxy (not self-invocation). Know read-only transactions optimization.
	81.	What is Spring Boot? Advantages?
	•	Opinionated framework simplifying Spring setup via auto-configuration, starters, embedded containers (Tomcat/Jetty), and production-ready features (Actuator). Advantage: minimal boilerplate, quick prototyping, easier production deployments.
	82.	What is auto-configuration?
	•	Spring Boot inspects classpath and beans and configures components automatically (e.g., DataSource when JDBC driver on classpath). Can be overridden by user-defined beans or properties.
	83.	What are starters?
	•	Dependency descriptors that bundle common dependencies: e.g., spring-boot-starter-web includes Spring MVC and Tomcat. Starters simplify dependency management.
	84.	Difference between application.properties and application.yml.
	•	Both configure Spring Boot. application.yml supports hierarchical configuration and is more readable for nested properties. properties is flat key=value. Functionally equivalent.
	85.	What are profiles in Spring Boot?
	•	Profiles (e.g., dev, prod) allow environment-specific configuration. Use @Profile on beans or application-{profile}.properties files. Activate via spring.profiles.active.
	86.	How to handle exceptions globally? (@ControllerAdvice)
	•	Use @ControllerAdvice with @ExceptionHandler methods to centralize exception handling across controllers, returning proper HTTP status and error payload.
	87.	How to build REST APIs in Spring Boot?
	•	Use @RestController (combines @Controller + @ResponseBody), @RequestMapping, @GetMapping, @PostMapping, request/response DTOs, validation (@Valid), error handling via @ControllerAdvice, and proper status codes. Use ResponseEntity for custom headers/status.
	88.	What is Actuator? What metrics does it provide?
	•	Spring Boot Actuator exposes production-ready endpoints: health, metrics (jvm.memory, process.cpu), info, env, beans, mappings. Can be extended with custom metrics, integrated with Micrometer for Prometheus/Grafana.
	89.	What is Spring Scheduler?
	•	@EnableScheduling + @Scheduled allows cron or fixed-rate tasks. Use ScheduledExecutorService for more control and externalize schedule in properties.
	90.	How do you secure Spring Boot APIs (JWT/OAuth2)?
	•	Use Spring Security: configure WebSecurityConfigurerAdapter (or new config style) to authorize endpoints, authenticate via JWT by verifying token in filter, or integrate with OAuth2 (Auth server/Keycloak). Use roles/authorities, CORS configuration, CSRF settings for web apps, and secure secrets via SecretManager.
	91.	What are microservices? Benefits?
	•	Architectural style splitting app into small, independently deployable services owned by small teams. Benefits: scalability, independent deployment, technology heterogeneity, fault isolation. Costs: operational complexity, distributed systems challenges (network, consistency).
	92.	Difference between monolithic and microservices architectures.
	•	Monolith: single deployable unit; simpler to develop initially but harder to scale and maintain at large sizes. Microservices: multiple services communicating over network; greater operational overhead but better modularity and scaling.
	93.	What is API Gateway?
	•	Single entry point for clients: handles authentication, routing, load balancing, rate limiting, request/response transformation, and can act as a TLS termination point. Examples: Spring Cloud Gateway, Kong, API Gateway in cloud providers.
	94.	What is Service Discovery? Eureka / Consul.
	•	Mechanism for services to discover each other without hard-coded addresses. Client-side discovery (Eureka): client queries registry and uses load-balancer. Server-side discovery (Kubernetes): router/load-balancer resolves services. Consul provides health checks, key-value store, and service catalog.
	95.	What is Load Balancing? Ribbon/Feign.
	•	Distributing requests across instances. Ribbon (now deprecated) provided client-side load balancing. Feign is a declarative HTTP client often combined with client-side load balancing. In Kubernetes, service and ingress provide load balancing.
	96.	How do microservices communicate? (REST, Kafka, gRPC)
	•	Synchronous: HTTP/REST, gRPC (fast, binary, supports streaming). Asynchronous: messaging/event-driven (Kafka, RabbitMQ) for decoupling, scalability, eventual consistency. Choose based on latency, coupling, and reliability needs.
	97.	What is Circuit Breaker? Hystrix / Resilience4j.
	•	Prevent cascading failures by short-circuiting calls to failing services. Hystrix deprecated; use Resilience4j for rate limiting, retries, circuit-breaking, bulkhead patterns.
	98.	What is distributed tracing? (Zipkin/Sleuth)
	•	Trace requests across services by propagating trace IDs/spans. Tools: OpenTelemetry, Zipkin, Jaeger. Useful to debug latency and path through microservices.
	99.	What is idempotency in microservices?
	•	Operation can be applied multiple times with same effect (no additional side-effects). Important for retries in distributed systems. Achieved via idempotency keys, dedup tables, or idempotent endpoints (PUT vs POST semantics).
	100.	How do you handle configuration in distributed systems? (Spring Cloud Config)
- Centralize configuration using config server (Spring Cloud Config) backed by Git or Vault for secrets. Use property overrides per profile, encrypted properties for secrets, and refresh mechanisms (/actuator/refresh) or dynamic config via feature flags. Use environment variables for containerized deployments.

⸻

That’s it — 100 complete answers.

If you want next steps, pick one:
	•	I can generate concise bullet cheat-sheets for each topic (2-3 lines each) for quick revision.
	•	Or I can expand any 10 questions into code examples + whiteboard-style diagrams (e.g., HashMap internals, ThreadPoolExecutor config, Spring Boot JWT filter).
	•	Or I can run a brutal mock interview: I’ll ask 8–10 live questions one-by-one, you answer, and I’ll give ruthless feedback + exact improvements.

Which of the three do you want now?
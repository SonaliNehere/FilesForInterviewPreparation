Perfect.
Below are 50 highly relevant, resume-based interview questions with detailed answers tailored to your skills:

Java (Core + J2EE), Spring Boot, Microservices, Elasticsearch, MongoDB, Redis, Docker, Kubernetes, Linux, Quartz Scheduler, Jetty, Security (RBAC, JWT, PQC), Distributed Systems, HTTP/2, Kafka (Learning), Advanced Spring Boot.

These are exactly the type senior-level questions youâ€™ll be asked based on the stack you mentioned.

â¸»

âœ… 50 Resume-Based Interview Questions With Detailed Answers

ðŸ”¥ A. Core Java â€“ 1 to 10

1. Explain how you would optimize a high-throughput Java microservice handling thousands of requests per second.

Answer:
	â€¢	Use thread pools with proper sizing (CPU-bound vs IO-bound).
	â€¢	Avoid blocking calls in request path.
	â€¢	Use non-blocking WebClient / reactive approach if needed.
	â€¢	Use efficient collections (ConcurrentHashMap, Disruptor pattern if extreme).
	â€¢	Cache repeated DB calls in Redis.
	â€¢	Tune JVM (G1GC, heap sizing).
	â€¢	Use connection pooling (HikariCP).
	â€¢	Profile using JFR or VisualVM.

â¸»

2. How would you implement a custom thread-safe cache in Java?

Answer:
	â€¢	Use ConcurrentHashMap with computeIfAbsent.
	â€¢	Wrap with TTL using ScheduledExecutorService.
	â€¢	Or use Caffeine for advanced eviction policies.
	â€¢	Avoid synchronized blocks as they reduce throughput.

â¸»

3. Difference between concurrency and parallelism?

Answer:
	â€¢	Concurrency: deals with multiple tasks in progress at the same time.
	â€¢	Parallelism: tasks execute simultaneously on multiple cores.
Your microservices benefit from concurrency (I/O tasks) and parallelism for CPU-heavy tasks like encryption or image processing.

â¸»

4. Explain volatile with a real use-case.

Answer:
volatile ensures visibility between threads.
Example: A real-time message consumerâ€™s isRunning flag.
Without volatile, one thread may never see updated values.

â¸»

5. What is false sharing? Why is it bad?

Answer:
	â€¢	When multiple threads modify variables located on the same CPU cache line â†’ cache invalidations â†’ performance drops.
	â€¢	Happens in high-throughput systems.
	â€¢	Fix: Padding variables using @Contended.

â¸»

6. How do you avoid memory leaks in Java?

Answer:
	â€¢	Remove references from static collections.
	â€¢	Close resources in try-with-resources.
	â€¢	Avoid ThreadLocal leaks in thread pools.
	â€¢	Use weak references for large cached objects.

â¸»

7. Explain CompletableFuture pipeline with example.

Answer:
	â€¢	Used for async programming:

CompletableFuture.supplyAsync(() -> fetchData())
                 .thenApply(data -> transform(data))
                 .thenAccept(result -> save(result));


â¸»

8. What is GC pause? How do you reduce it?

Answer:
	â€¢	When JVM stops the application to collect garbage.
	â€¢	Reduce by:
	â€¢	G1GC/Low-latency collectors
	â€¢	Reducing allocation rate
	â€¢	Using object pooling for repetitive operations

â¸»

9. How does Java handle large file streaming?

Answer:
Use NIO channels:
FileChannel â†’ zero-copy (transferTo) â†’ extremely fast for log sync or file uploads.

â¸»

10. Why is String immutable, and how does it help security?

Answer:
	â€¢	Allows strings in pool.
	â€¢	Thread-safe.
	â€¢	Prevents modification of credentials, URLs, etc.

â¸»

ðŸ”¥ B. Spring Boot & Microservices â€“ 11 to 25

11. Explain how you design a microservice using Spring Boot.

Answer:
	â€¢	REST controller â†’ service layer â†’ repository layer
	â€¢	DTO â†’ Entity â†’ Mapper
	â€¢	Exception handling via @ControllerAdvice
	â€¢	Logging with SLF4J
	â€¢	Security via Spring Security + JWT
	â€¢	Config via application.yml
	â€¢	Use Actuator for health checks
	â€¢	Containerize and deploy on Kubernetes.

â¸»

12. What problem does Spring IoC solve?

Answer:
Removes tight coupling.
Spring handles object creation, dependency wiring â†’ more testable, clean, maintainable.

â¸»

13. How would you implement role-based access control (RBAC) in Spring Security?

Answer:
	â€¢	Users + Roles stored in DB.
	â€¢	When authenticated, JWT contains roles.
	â€¢	Method-level security using:

@PreAuthorize("hasRole('ADMIN')")


â¸»

14. Explain internal working of DispatcherServlet.

Answer:
	â€¢	Front controller mapping all requests.
	â€¢	Finds correct handler (controller) via HandlerMapping.
	â€¢	Calls HandlerAdapter â†’ controller.
	â€¢	Gets ModelAndView â†’ resolves view.
	â€¢	Sends response.

â¸»

15. What is the use of @Transactional?

Answer:
	â€¢	Wraps method in transaction boundary.
	â€¢	Rolls back on RuntimeExceptions.
	â€¢	Propagation ensures proper transaction nesting.

â¸»

16. How do you handle exceptions globally?

Answer:
Using @ControllerAdvice:

@ExceptionHandler(CustomException.class)
public ResponseEntity<?> handle(CustomException e) { ... }


â¸»

17. How do you secure microservices with JWT?

Answer:
	â€¢	Authenticate user â†’ generate JWT.
	â€¢	For each request: JWT filter extracts token â†’ decode â†’ validate signature â†’ load roles â†’ set Authentication.
	â€¢	Stateless, scalable.

â¸»

18. How do you implement caching in Spring Boot using Redis?

Answer:

@Cacheable(value="users", key="#id")
public User getUser(int id){}

Redis holds frequently accessed results â†’ huge performance boost.

â¸»

19. Explain Spring Boot AutoConfiguration.

Answer:
Spring scans classpath â†’ auto-configures beans if conditions match (e.g., if HikariCP is present, DataSource auto-configured).

â¸»

20. Difference between RestTemplate, WebClient, FeignClient.

Answer:
	â€¢	RestTemplate: blocking, legacy.
	â€¢	WebClient: non-blocking, reactive.
	â€¢	FeignClient: declarative, simplifies REST calls in microservices.

â¸»

21. What is Spring Cloud Gateway and why use it?

Answer:
API Gateway for microservices:
	â€¢	Routing
	â€¢	Rate-limiting
	â€¢	CORS
	â€¢	Request/response filters
	â€¢	Authentication layer

â¸»

22. How do you implement configuration management in distributed systems?

Answer:
	â€¢	Spring Cloud Config Server
	â€¢	Stores config in Git
	â€¢	Microservices fetch config from config server
	â€¢	Dynamic refresh with actuator endpoint.

â¸»

23. What is Circuit Breaker pattern?

Answer:
Stops calling a failing service to prevent cascading failures.
Use Resilience4J.

â¸»

24. How to improve resilience in microservices?

Answer:
	â€¢	Retry pattern
	â€¢	Fallback
	â€¢	Circuit breaker
	â€¢	Bulkhead isolation
	â€¢	Timeout configuration
	â€¢	Async communication (Kafka)

â¸»

25. Explain idempotency with real example.

Answer:
In payment/transaction APIs:
Multiple retries shouldnâ€™t create duplicate orders.
Use Idempotency-Key or unique request token.

â¸»

ðŸ”¥ C. Databases: MongoDB, Redis, Elasticsearch â€“ 26 to 33

26. Why use MongoDB for microservices?

Answer:
	â€¢	Flexible schema
	â€¢	Fast writes
	â€¢	Perfect for JSON-based REST APIs
	â€¢	Sharding â†’ horizontal scalability
	â€¢	Great for log/event storage

â¸»

27. How to model relationships in MongoDB?

Answer:
	â€¢	Embed small documents
	â€¢	Reference large ones
Tradeoff: consistency vs performance.

â¸»

28. When would you choose Elasticsearch?

Answer:
	â€¢	Full-text search
	â€¢	Aggregations
	â€¢	Log/analytics
	â€¢	Real-time filtering
	â€¢	Complex querying (fuzzy, wildcard, prefix)

â¸»

29. Explain ES inverted index.

Answer:
ES breaks text into tokens â†’ builds dictionary where each token maps to document IDs.
This makes search O(1) by keyword.

â¸»

30. Explain Redis use cases in microservices.

Answer:
	â€¢	Caching
	â€¢	Distributed locks
	â€¢	Session store
	â€¢	Rate limiting
	â€¢	Leaderboards / counters
	â€¢	Pub/Sub

â¸»

31. How do you implement distributed lock in Redis?

Answer:
Using SETNX:

SET lockKey value NX PX 30000

Ensures only one service instance gets the lock.

â¸»

32. How to handle cache invalidation?

Answer:
Patterns:
	â€¢	Time-based TTL
	â€¢	Cache-aside (on miss â†’ DB â†’ cache)
	â€¢	Write-through
	â€¢	Write-behind

â¸»

33. How to index documents efficiently in Elasticsearch?

Answer:
Batch indexing using Bulk API.
Use smaller shards, disable refresh temporarily, increase refresh interval.

â¸»

ðŸ”¥ D. Distributed Systems & Kafka â€“ 34 to 42

34. What causes latency in distributed systems?

Answer:
	â€¢	Network hops
	â€¢	Serialization/deserialization
	â€¢	Database bottlenecks
	â€¢	GC pauses
	â€¢	Thread starvation
	â€¢	Load imbalance
	â€¢	Contention on locks

â¸»

35. What is backpressure? How do you handle it?

Answer:
When producers push data faster than consumers can handle.
Solutions:
	â€¢	Kafka to buffer
	â€¢	Async processing
	â€¢	Thread pools
	â€¢	Rate limiting

â¸»

36. Explain Kafka consumer group.

Answer:
	â€¢	Each partition is consumed by only one consumer in the group.
	â€¢	Group allows horizontal scaling.
	â€¢	Rebalancing happens when consumers join/leave.

â¸»

37. How to ensure exactly-once processing in Kafka?

Answer:
	â€¢	Enable idempotent producers
	â€¢	Use transactional writes
	â€¢	Write to DB + produce output atomically
	â€¢	Use message keys for deduplication

â¸»

38. How would you design event-driven microservice?

Answer:
	â€¢	Producer publishes events to Kafka
	â€¢	Consumers subscribe to topics
	â€¢	Retry and DLQ (Dead Letter Queue)
	â€¢	Event schema stored in Schema registry
	â€¢	Idempotent handlers

â¸»

39. Difference between Kafka and RabbitMQ?

Answer:
	â€¢	Kafka = distributed log, high throughput, event streaming
	â€¢	RabbitMQ = message broker, better for transactional queues, priority messages

â¸»

40. Why partitioning is important in Kafka?

Answer:
	â€¢	Enables parallelism
	â€¢	Increases throughput
	â€¢	Ensures ordering within partition
	â€¢	Distributes load

â¸»

41. How do you handle message retries?

Answer:
	â€¢	Manual commit
	â€¢	Retry topics
	â€¢	DLQ
	â€¢	Exponential backoff using Spring Kafka RetryTemplate

â¸»

42. Why use HTTP/2 in microservices?

Answer:
	â€¢	Multiplexing
	â€¢	Header compression
	â€¢	Lower latency
	â€¢	Server push
Ideal for real-time analytics or chat pipelines.

â¸»

ðŸ”¥ E. DevOps: Docker, Kubernetes, Linux â€“ 43 to 50

43. How would you containerize a Spring Boot application?

Answer:
	â€¢	Use multi-stage Dockerfile
	â€¢	Build JAR â†’ copy to small base image (Eclipse Temurin)
	â€¢	Expose port 8080
	â€¢	Health checks
Example:

FROM gradle:latest as builder
WORKDIR /app
COPY . .
RUN gradle build --no-daemon

FROM eclipse-temurin:17
COPY --from=builder /app/build/libs/app.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]


â¸»

44. Explain Kubernetes readiness and liveness probes.

Answer:
	â€¢	Liveness probe: checks if app is healthy; if fails â†’ restart container.
	â€¢	Readiness probe: checks if app is ready to serve traffic; if fails â†’ remove from load balancer.

â¸»

45. How do you handle auto-scaling in Kubernetes?

Answer:
Horizontal Pod Autoscaler (HPA):
	â€¢	Based on CPU/memory
	â€¢	Or custom metrics (Kafka lag, request per second)

â¸»

46. What is a ConfigMap vs Secret?

Answer:
	â€¢	ConfigMap: stores non-sensitive config
	â€¢	Secret: stores base64 encoded sensitive data

â¸»

47. Explain service types in Kubernetes.

Answer:
	â€¢	ClusterIP â†’ internal
	â€¢	NodePort â†’ expose on node IP
	â€¢	LoadBalancer â†’ public cloud LB
	â€¢	Ingress â†’ route HTTP based on paths/hosts

â¸»

48. How do you debug container memory leaks?

Answer:
	â€¢	Use jmap, jstat
	â€¢	Heap dump from inside container
	â€¢	Use docker stats
	â€¢	Tune JVM inside container (-XX:+UseContainerSupport)

â¸»

49. How do you optimize Spring Boot memory usage in containers?

Answer:
	â€¢	Set fixed heap
	â€¢	Disable unnecessary auto-configurations
	â€¢	Use spring.jmx.enabled=false
	â€¢	Container-aware JVM settings
	â€¢	Reduce thread pools

â¸»

50. What is a sidecar container pattern?

Answer:
A helper container running alongside main container.
Examples:
	â€¢	Logging agent
	â€¢	Proxy like Envoy
	â€¢	Sidecar for security (JWT validation)

â¸»

âœ… Want me to generate coding examples for these 50 questions?

Or do you want 50 more advanced questions for senior-level roles?
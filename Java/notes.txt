1. Arrays.stream(arr) doesn’t work for a char[] array.
That method is only overloaded for:
int[]
long[]
double[]
T[] (object arrays)
Since char is a primitive type, you can’t use Arrays.stream(char[]) directly.

2. The s.chars() method returns an IntStream.
When you cast inside map, you’re still producing an IntStream.
To get a stream of characters, use mapToObj() instead.
s.chars() → gives an IntStream of Unicode values.
.mapToObj(c -> (char)c) → converts each code into a Character.
.filter(c -> s.indexOf(c) == s.lastIndexOf(c)) → keeps only unique characters.
.findFirst() → picks the first such character in the order they appear.
.ifPresent(System.out::println) → prints it safely (avoids NoSuchElementException).

4. Feature	trim()	                strip()
Introduced   in	Java 1.0	          Java 11
Removes	    Only ASCII spaces	      Unicode + ASCII spaces
Uses	      Character code ≤ 32	    Character.isWhitespace()
Recommended for modern code	❌	    ✅
✅ Bonus:
stripLeading() → removes spaces only at the start
stripTrailing() → removes spaces only at the end

5. Arrays.toString(array)

6. Arrays.stream(arr) — converts the int[] to an IntStream(its different from stream of Integer).
    .boxed() — converts primitive int values to Integer objects.
    .toList() — collects them into a List.

7. java.time.LocalDateTime.now()

8. Collections.sort(list, Collections.reverseOrder());
    Collections.reverse(list);

9. Integer.toBinaryString(i) - convert int to binary

10. .sorted(Comparator.comparingInt(Employee::getSalary))
    .sorted((e1, e2) -> Integer.compare(e1.getSalary(), e2.getSalary()))
    .sorted(Comparator.comparingInt(Employee::getSalary).reversed())
    .sorted((e1, e2) -> Integer.compare(e2.getSalary(), e1.getSalary()))

    “Subtracting values inside a comparator (a - b) may cause integer overflow and break comparator rules, so we should avoid using the - operator for sorting.         Instead, we use Integer.compare() or Comparator.comparingInt().”

   11. Comparable and comparator
    "
    class Employee implements Comparable<Employee> {
    int salary;

    Employee(int salary) { this.salary = salary; }

    @Override
    public int compareTo(Employee o) {
        return Integer.compare(this.salary, o.salary);  // natural order
    }
    }

    List<Employee> list = Arrays.asList(
        new Employee(3000),
        new Employee(1000),
        new Employee(2000)
    );

// 1️⃣ Using Comparable
Collections.sort(list);   // ascending
list.sort(null);          // ascending

// 2️⃣ Using Comparator
Comparator<Employee> desc =
        (e1, e2) -> Integer.compare(e2.salary, e1.salary);

Collections.sort(list, desc); // descending
list.sort(desc);              // descending
"
✔ If you call:
list.sort();  - This won’t compile.
Because list.sort() requires an argument — either: a Comparator, or null (meaning use Comparable / natural ordering). So you MUST pass something.






